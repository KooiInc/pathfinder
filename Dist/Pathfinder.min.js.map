{
  "version": 3,
  "sources": ["../src/PathFinder.js"],
  "sourcesContent": ["const cleanPath = path => /^[/.]/.test(path) ? path.slice(1) : path;\r\nconst splitPath = path => (cleanPath(path)).split(/[/.]/);\r\nconst isObj = o => Object.getPrototypeOf(o || 0).constructor === Object;\r\nconst checkArray = (shouldCheck, value) => shouldCheck && Array.isArray(value) && !!value.find(v => v.constructor && v.constructor === Object);\r\nconst noValue = `no value (undefined)`;\r\nconst invObj = `None. Object instance not suitable`;\r\nconst createReturnValue = (path = `n/a`, exists = false[yn], value = noValue) => ({searchPath: path, exists: exists[yn], value});\r\nconst validObj = obj => !Array.isArray(obj) && Object.keys(obj).length;\r\nconst { pathTo, fromPath, yn } = extendSymbolic();\r\n\r\nexport { pathTo, fromPath };\r\n\r\nfunction extendSymbolic() {\r\n  Symbol.to =Symbol.for(`pathTo`);\r\n  Symbol.from =Symbol.for(`pathFrom`);\r\n  Symbol.yn = Symbol.for(`yn`)\r\n  \r\n  Object.defineProperties(Boolean.prototype, {\r\n    [Symbol.yn]: { value: yn, enumerable: false, },\r\n  })\r\n  \r\n  Object.defineProperties(Object.prototype, {\r\n    [Symbol.to]: { value: function(key) { return extTo(this, key); }, enumerable: false },\r\n    [Symbol.from]: { value: function(key) { return extFrom(this, key); }, enumerable: false },\r\n  });\r\n  \r\n  return { pathTo: Symbol.to, fromPath: Symbol.from, yn: Symbol.yn };\r\n  \r\n  function extTo(target, key) {\r\n    return validObj(target) && findPathForKey(target, key) || {\r\n      searchKey: key,\r\n      pathFound: invObj,\r\n      value: `n/a`\r\n    };\r\n  }\r\n  \r\n  function extFrom(target, path) {\r\n    return validObj(target) && getValueFromPath(target, path) || createReturnValue(path, false, `n/a`);\r\n  }\r\n  \r\n  function yn() { return !this.valueOf() ? `NO` : `YES`; }\r\n}\r\n\r\nfunction getValueFromPath(\r\n    object2Search,\r\n    pathString,\r\n    searchArraysForPathInObjects = false,\r\n    returnFoundObjectFromArrayIfPathFoundWithin = false ) {\r\n  const iPath = splitPath(pathString);\r\n  const exists = currentObj => {\r\n    const current = iPath.shift();\r\n\r\n    if (checkArray(searchArraysForPathInObjects, currentObj[current])) {\r\n      const retrievedFromArray = currentObj[current]\r\n        .find(v => getValueFromPath(v, iPath.join(\"/\"), 1).exists);\r\n\r\n      return retrievedFromArray\r\n        ? returnFoundObjectFromArrayIfPathFoundWithin\r\n          ? createReturnValue(pathString, true, retrievedFromArray)\r\n          : getValueFromPath(retrievedFromArray, iPath.join(\"/\"), 1)\r\n        : createReturnValue(pathString, false);\r\n    }\r\n\r\n    return Object.hasOwn(currentObj, current) && iPath.length\r\n      ? exists(currentObj[current])\r\n      : { ...createReturnValue(pathString, current in currentObj, currentObj[current]),\r\n        setValue: value => currentObj[current] = value };\r\n  };\r\n\r\n  if (checkArray(searchArraysForPathInObjects, object2Search)) {\r\n    object2Search = {root: object2Search};\r\n  }\r\n  return exists(object2Search);\r\n}\r\n\r\nfunction findPathForKey(initialObj, key) {\r\n  let result = {\r\n    searchKey: key,\r\n    pathFound: false[yn],\r\n  };\r\n\r\n  function loop(obj, key, path = ``) {\r\n    for (let k of Object.keys(obj)) {\r\n      if (k !== key && isObj(obj[k])) {\r\n        loop( obj[k], key, `${path}.${k}` );\r\n      }\r\n\r\n      if (k === key) {\r\n        result.pathFound = `${path}.${key}`.replace(/^\\./, ``);\r\n        result.value = obj[k] === undefined && noValue || obj[k];\r\n        result.cloneWithNewValue = value => {\r\n          const cloned = window[`structuredClone`]\r\n            ? window[`structuredClone`](initialObj) : JSON.parse(JSON.stringify(initialObj));\r\n          const currentValue = getValueFromPath(cloned, result.pathFound);\r\n\r\n          if (Object.hasOwn(currentValue, `setValue`)) {\r\n            currentValue.setValue(value); // Note: by reference\r\n          }\r\n\r\n          return cloned;\r\n        };\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!Object.hasOwn(result, `value`)) { result.value = `No path for key '${key}'`; }\r\n\r\n    return result;\r\n  }\r\n\r\n  return loop(initialObj, key);\r\n}"],
  "mappings": "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",
  "names": ["cleanPath", "path", "splitPath", "isObj", "o", "checkArray", "shouldCheck", "value", "v", "noValue", "invObj", "createReturnValue", "exists", "yn", "validObj", "obj", "pathTo", "fromPath", "extendSymbolic", "extendSymbolic", "yn", "key", "extTo", "extFrom", "target", "validObj", "findPathForKey", "invObj", "path", "getValueFromPath", "createReturnValue", "object2Search", "pathString", "searchArraysForPathInObjects", "returnFoundObjectFromArrayIfPathFoundWithin", "iPath", "splitPath", "exists", "currentObj", "current", "checkArray", "retrievedFromArray", "v", "value", "initialObj", "result", "loop", "obj", "k", "isObj", "noValue", "cloned", "currentValue"]
}
